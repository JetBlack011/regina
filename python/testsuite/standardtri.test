# Regina - A Normal Surface Theory Calculator
# Python Test Suite Component
#
# Copyright (c) 2007-2021, Ben Burton
# For further details contact Ben Burton (bab@debian.org).
#
# Tests the census database lookup routines.
#
# This file is a single component of Regina's python test suite.  To run
# the python test suite, move to the main python directory in the source
# tree and run "make check".
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of the
# License, or (at your option) any later version.
#
# As an exception, when this program is distributed through (i) the
# App Store by Apple Inc.; (ii) the Mac App Store by Apple Inc.; or
# (iii) Google Play by Google Inc., then that store may impose any
# digital rights management, device limits and/or redistribution
# restrictions that are required by its terms of service.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public
# License along with this program; if not, write to the Free
# Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
# MA 02110-1301, USA.

from __future__ import print_function

def prefix(n):
	return '  ' * n

def describe(t, name):
	print(name + ':')
	print(prefix(1) + 'IsoSig: ' + t.isoSig())

	std = StandardTriangulation.recognise(t)
	if std:
		print(prefix(1) + 'Standard: ' + std.name())
		mfd = std.manifold()
		if mfd:
			print(prefix(1) + 'Manifold: ' + mfd.name())

	# We assume the triangulation is connected.
	c = t.component(0)

	sub = AugTriSolidTorus.recognise(c)
	if sub:
		print(prefix(1) + 'Augmented triangular solid torus: ' + sub.name())
		core = sub.core()
		print(prefix(2) + 'Core tets:', core.tetrahedron(0).index(),
			core.tetrahedron(1).index(), core.tetrahedron(2).index())
		if sub.hasLayeredChain():
			print(prefix(2) + 'Attached: layered chain + layered solid tori')
			if sub.chainType() == AugTriSolidTorus.CHAIN_MAJOR:
				print(prefix(2) + 'Chain type: major')
			elif sub.chainType() == AugTriSolidTorus.CHAIN_AXIS:
				print(prefix(2) + 'Chain type: axis')
			else:
				print(prefix(2) + 'Chain type: unknown')
		else:
			print(prefix(2) + 'Attached: 3 layered solid tori')

	sub = L31Pillow.recognise(c)
	if sub:
		print(prefix(1) + 'L(3,1) pillow: ' + sub.name())
		print(prefix(2) + 'Interior vertex:',
			sub.tetrahedron(0).vertex(sub.interiorVertex(0)).index())

	sub = LayeredChainPair.recognise(c)
	if sub:
		print(prefix(1) + 'Layered chain pair: ' + sub.name())
		print(prefix(2) + 'Chain lengths:',
			sub.chain(0).index(), sub.chain(1).index())

	sub = LayeredLensSpace.recognise(c)
	if sub:
		print(prefix(1) + 'Layered lens space: ' + sub.name())
		torus = sub.torus()
		print(prefix(2) + 'LST:', torus.meridinalCuts(0),
			torus.meridinalCuts(1), torus.meridinalCuts(2))
		if sub.isSnapped():
			print(prefix(2) + 'Snapped shut')
		else:
			print(prefix(2) + 'Twisted shut')

	# TODO: findLayeredLoops
	# TODO: findPlugTriSolidTori
	# TODO: findBlockedTriangulations
	# TODO: findPillowSpheres
	# TODO: findSnappedSpheres

	for tet in t.tetrahedra():
		sub = LayeredSolidTorus.recogniseFromBase(tet)
		if sub:
			print(prefix(1) + 'Layered solid torus: ' + sub.name())
			print(prefix(2) + 'Base tet:', sub.base().index())
			print(prefix(2) + 'Top tet:', sub.topLevel().index())
			print(prefix(2) + 'Meridinal cuts:', sub.meridinalCuts(0),
				sub.meridinalCuts(1), sub.meridinalCuts(2))
			print(prefix(2) + 'Edges for cut 0:',
				sub.topEdge(0, 0), sub.topEdge(0, 1))
			print(prefix(2) + 'Edges for cut 1:',
				sub.topEdge(1, 0), sub.topEdge(1, 1))
			print(prefix(2) + 'Edges for cut 2:',
				sub.topEdge(2, 0), sub.topEdge(2, 1))

	# findSnappedBalls
	# findSpiralSolidTori

def describeSig(sig):
	describe(Triangulation3.fromIsoSig(sig), sig)

# The following isosigs are the complete output of tricensus -sNfit<n>:

t1 = [ 'bkaajj', 'bkaajn', 'bkaagb', 'bkaagj' ]
t2 = [ 'cMcabbjqw', 'cMcabbjxr', 'cMcabbjaj', 'cMcabbjak', 'cMcabbjqs',
	'cMcabbgqw', 'cMcabbgaj', 'cPcbbbaaa', 'cPcbbbaai', 'cPcbbbqxh',
	'cPcbbbajs', 'cPcbbbahh' ]
t3 = [ 'dLQbcbchhww', 'dLQbcbchxwn', 'dLQbcbchhjw', 'dLQbcbchxjn',
	'dLQbcbchhjs', 'dLQbcbchxjj', 'dLQbccchhrw' ]
t4 = [ 'eLAkbcbddhhwhr', 'eLAkbcbddhhwqj', 'eLAkbcbddhxwqs', 'eLAkbcbddhhjhr',
	'eLAkbcbddhhjqj', 'eLAkbcbddhhwqn', 'eLAkbcbddhxjqs', 'eLAkbcbddhhjhk',
	'eLAkbcbddhhjqn', 'eLAkbcbddhxjqw', 'eLAkbccddemkiw', 'eLAkbccddemker',
	'eLAkbccddrrhrr', 'eLAkbccddemkij', 'eLAkbccddemken', 'eLAkbccddrrhrn',
	'eLMkbcdddhhhqx', 'eLPkbcdddhrrnk', 'eLPkbcddddrwos' ]
t5 = [ 'fLAMcbcbdeehhwhhw', 'fLAMcbcbdeehhwqqs', 'fLAMcbcbdeehhwhxn',
	'fLAMcbcbdeehxwxhw', 'fLAMcbcbdeehhwqxk', 'fLAMcbcbdeehxwqhr',
	'fLAMcbcbdeehhjhhw', 'fLAMcbcbdeehhjhxn', 'fLAMcbcbdeehhjqqs',
	'fLAMcbcbdeehhjqxk', 'fLAMcbcbdeehhwhxj', 'fLAMcbcbdeehxjxhw',
	'fLAMcbcbdeehhwqxr', 'fLAMcbcbdeehxjqhr', 'fLAMcbcbdeehhjhhs',
	'fLAMcbcbdeehhjqqw', 'fLAMcbcbdeehhjhxj', 'fLAMcbcbdeehxjxhs',
	'fLAMcbcbdeehhjqxr', 'fLAMcbcbdeehxjqhk', 'fLAMcbccdeeemkihr',
	'fLAMcbccdeeemkehw', 'fLAMcbccdeerrhrhw', 'fLAMcbccdeeemkiqj',
	'fLAMcbccdeeemkexn', 'fLAMcbccdeerrhrxn', 'fLAMcbccdeeemkihn',
	'fLAMcbccdeeemkehj', 'fLAMcbccdeerrhrhj', 'fLAMcbccdeeemkiqn',
	'fLAMcbccdeeemkexj', 'fLAMcbccdeerrhrxj', 'fLLQcacddeenkaikr',
	'fLLQcacddeejkaink', 'fLLQcaceeedjkuxkn', 'fLLQcacddeejkaikk',
	'fLLQcaceeedjkuxkj', 'fLLQcacddeejkaikr', 'fLLQcacddeejkainj',
	'fLLQcacddeenkaink', 'fLLQcaceeednkuxkn', 'fLLQcacddeenkaikk',
	'fLLQcacdeeenkqxvn', 'fLLQcacdeeenkaqnv', 'fLLQcacdeeejkqxvn',
	'fLLQcacdeeejkaqnv', 'fLMPcbcdeeehhhhwr', 'fLLQcbeddeehhnkxx',
	'fLLQcbededexxnxwx', 'fLLQcbededexxrxwx', 'fLLQcbeddeehhokum',
	'fLLQcbcdeeehwkiiq', 'fvPQcdecedekrsnrs', 'fvPQcceddeerrnskr' ]

for i in t1:
	describeSig(i)
for i in t2:
	describeSig(i)
for i in t3:
	describeSig(i)
for i in t4:
	describeSig(i)
for i in t5:
	describeSig(i)

