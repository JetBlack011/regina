<chapter id="foreign">
 <title>Importing and Exporting Data</title>

 <para>
  By default, &regina; reads and writes
  <filename>.rga</filename> data files in its own compressed
  &xml; file format.
  However, &regina; can also import data from and export data to several
  other file formats, which allows you to pass data between &regina; and
  other applications.
  This chapter outlines the available import and export formats.
 </para>
 <para>
  If you are writing filters for some other program and you need a full
  specification for &regina;'s own &xml; file format, select
  <menuchoice>
   <guimenu>Help</guimenu>
   <guisubmenu>File Format Reference</guisubmenu>
  </menuchoice> from the menu.
 </para>

 <sect1 id="foreign-import">
  <title>Importing</title>

  <para>
   An <firstterm>import</firstterm> involves reading data from some
   foreign file format and inserting it into your working packet tree
   (effectively merging it into whatever file you already have open).
   All imports are done through the
   <menuchoice>
    <guimenu>File</guimenu>
    <guisubmenu>Import</guisubmenu>
   </menuchoice>
   menu.
  </para>
  <para>
   <inlinemediaobject>
    <imageobject>
     <imagedata fileref="menu-import.png"/>
    </imageobject>
   </inlinemediaobject>
  </para>
  <para>
   The
   <menuchoice>
    <guimenu>File</guimenu>
    <guisubmenu>Import</guisubmenu>
   </menuchoice>
   menu will <emphasis>only appear once you have a file open</emphasis>.
   If you have just started up &regina;, you will first need to create a
   new file by selecting
   <menuchoice>
    <guimenu>File</guimenu>
    <guimenuitem>New Topology Data</guimenuitem>
   </menuchoice>
   (or pressing the corresponding toolbar button).
  </para>
  <para>
   When you select an action from the
   <menuchoice>
    <guimenu>File</guimenu>
    <guisubmenu>Import</guisubmenu>
   </menuchoice>
   menu, you will first be asked to select a file.
   Once you have chosen the file to import, a second window will appear
   asking for additional details:
  </para>
  <para>
   <inlinemediaobject>
    <imageobject>
     <imagedata fileref="import-snappea.png"/>
    </imageobject>
   </inlinemediaobject>
  </para>
  <para>
   <glosslist>
    <glossentry>
     <glossterm><guilabel>Import beneath:</guilabel></glossterm>
     <glossdef><para>
      Here you select where in the packet tree the imported data will appear.
      The import will be added as a new packet, immediately beneath
      whatever &ldquo;parent&rdquo; packet you choose here.
     </para></glossdef>
    </glossentry>
    <glossentry id="import-label">
     <glossterm><guilabel>Label:</guilabel></glossterm>
     <glossdef><para>
      This will be the label (i.e., the name) of the new packet containing
      the imported data.
      No two packets in the same data file may have the same label.
     </para></glossdef>
    </glossentry>
   </glosslist>
  </para>
  <para>
   &regina; can import data from the following file formats:
  </para>

  <sect2 id="import-regina">
   <title>&regina; Data Files</title>

   <para>
    You can import another &regina; data file.
    This effectively lets you insert the contents of one file inside another.
   </para>
   <para>
    This is a convenient way of merging two data files into one.
    You can also merge data files from the command-line using the
    <link linkend="man-regconcat"><command>regconcat</command></link>
    utility.
   </para>
  </sect2>

  <sect2 id="import-snappea">
   <title>&snappea; Triangulations</title>

   <para>
    You can import a triangulation from &snappea;.
    &snappea; is the excellent software written by Jeffrey Weeks
    for studying hyperbolic 3-manifolds;
    for more information on &snappea; and its successor &snappy;,
    see the &snappywebsite;.
    Note that you can also perform some &snappea; calculations
    <link linkend="tri-snappea">directly within &regina;</link>.
   </para>
   <para>
    The file that you import should be a plain text file in
    &snappea;'s triangulation format; an example is shown below.
    Any international characters should be encoded in &utf8;.
   </para>
   <programlisting>
    % Triangulation
    m002
    geometric_solution  2.02988321
    nonorientable_manifold
    CS_unknown

    0 2
        Klein   0.000000000000   0.000000000000
        Klein   0.000000000000   0.000000000000

    2
       1    1    1    1
     0132 3120 2130 3102
       0    1    0    0
      0  0  0  0  0  0  1 -1  0  0  0  0  1 -1  0  0
      0  1 -1  0  0  0  0  0 -1  0  0  1  0  0  0  0
      0  0  1 -1 -1  0  1  0  1  0  0 -1 -1  1  0  0
      0  0  1 -1 -1  0  1  0  1  0  0 -1 -1  1  0  0
      0.500000000000   0.866025403784

       0    0    0    0
     0132 3120 2130 3102
       0    1    0    0
      0  1 -1  0  0  0  0  0 -1  0  0  1  0  0  0  0
      0  0  0  0  0  0  1 -1  0  0  0  0  1 -1  0  0
      0 -1  1  0  1  0  0 -1  1  0  0 -1 -1  0  1  0
      0 -1  1  0  1  0  0 -1  1  0  0 -1 -1  0  1  0
      0.500000000000   0.866025403784
   </programlisting>
  </sect2>

  <sect2 id="import-orb">
   <title>&orbcasson; Triangulations</title>

   <para>
    You can import a triangulation from &orbcasson; format.
    &orburl; is a variant of &snappea; for calculating hyperbolic
    structures on 3-orbifolds and 3-manifolds, written by Damien Heard.
   </para>
   <para>
    The file that you import
    should be a plain text file in &orbcasson; format, which
    describes a triangulation in terms of its 1-skeleton.  The beginning
    of an example file is illustrated below.
    Any international characters should be encoded in &utf8;.
   </para>
   <programlisting>
    % orb
    8knot
    1  0  1.000  1vu  2uw  1ux  2xv  1xw  2vu
    2  0  1.000  1wu  2wx  1xv  2xu  1vw  2vw

    ...
   </programlisting>
  </sect2>

  <sect2 id="import-isosiglist">
   <title>Isomorphism Signature Lists</title>

   <para>
    You can import a list of isomorphism signatures from a text file.
    This is a space-efficient, plain-text method of storing a list
    of 3-manifold triangulations.
   </para>
   <para>
    An <firstterm>isomorphism signature</firstterm> is a
    compact sequence of letters, digits and/or punctuation that identifies a
    triangulation uniquely up to combinatorial isomorphism.
    See the <link linkend="tri-composition-isosig">composition viewer</link>
    for a more detailed discussion on isomorphism signatures, or
    <xref linkend="bib-burton-simps3"/> for examples of where they
    can be used.
   </para>
   <para>
    The list should be stored in a plain text file with one triangulation
    per line.  Each line may contain an arbitrary amount of data, but the
    first word of each line should be the isomorphism signature.
    Note that isomorphism signatures are <emphasis>case sensitive</emphasis>
    (i.e., upper-case and lower-case matter).  An example file is shown below.
   </para>
   <programlisting>
    dLQbcbchxjn   L(11,3)
    dLQbcbchxjj   L(10,3)
    dLQbcbcahrs   L(5,2)
    dLQbcbcahks   S3
    dLQbcbchhjw   L(9,2)
   </programlisting>
   <para>
    The import will appear in your packet tree as a new
    <link linkend="packet-container">container</link>,
    which will contain a new triangulation for each isomorphism signature
    in the list.
   </para>
   <para>
    <inlinemediaobject>
     <imageobject>
      <imagedata fileref="import-isosig.png"/>
     </imageobject>
    </inlinemediaobject>
   </para>
   <para>
    If you just wish to reconstruct a triangulation from a single
    isomorphism signature (not from many signatures), you can do this
    more easily by creating a
    <link linkend="tri-new-isosig">new triangulation</link>.
   </para>
  </sect2>

  <sect2 id="import-dehydrationlist">
   <title>Dehydrated Triangulation Lists</title>

   <para>
    You can import a list of dehydration strings from a text file.
    Like <link linkend="import-isosiglist">isomorphism signatures</link>,
    dehydration strings allow you to encode a list of triangulations in
    a space-efficient, plain-text manner.
   </para>
   <para>
    Dehydration strings are
    <link linkend="tri-composition-dehydration">less powerful</link>
    than isomorphism signatures.  They feature in hyperbolic census papers
    such as <xref linkend="bib-cuspedcensus"/>,
    in which the dehydration format is explicitly described.
   </para>
   <para>
    The list should be stored in a plain text file with one triangulation
    per line.  Each line may contain an arbitrary amount of data, but the
    first word of each line should be the dehydration
    string.  An example file is shown below.
   </para>
   <programlisting>
    dafbcccaadl   N3,1   Z/3 + Z
    dadcbccdjkd   N3,2   Z
    dadbcccbbcv   N3,3   Z
    dadbcccccdm   N3,4   Z
    dadbcccaqhx   N3,5   Z/2 + Z/2 + Z
   </programlisting>
   <para>
    As with isomorphism signatures,
    the import will appear in your packet tree as a new
    <link linkend="packet-container">container</link>,
    which will contain a new triangulation for each dehydration string
    in the list.
   </para>
   <para>
    If you just wish to reconstruct a triangulation from a single
    dehydration string (not from many strings), you can do this
    more easily by creating a
    <link linkend="tri-new-dehydration">new triangulation</link>.
   </para>
  </sect2>

  <sect2 id="import-pdf">
   <title>&pdf; Documents</title>

   <para>
    You can import a &pdf; document, which will appear in your data file
    as a <link linkend="packet-pdf">&pdf; packet</link>.
    This you to document your work with formulae, diagrams and
    anything else that can appear on the printed page.
   </para>
   <para>
    This is the only way of creating a &pdf; packet within &regina;.
    If you select
    <menuchoice>
     <guimenu>Packet Tree</guimenu>
     <guimenuitem>New PDF Document</guimenuitem>
    </menuchoice>
    from the menu, &regina; will go through exactly the same import
    process as described here.
   </para>
  </sect2>

  <sect2 id="import-pyscript">
   <title>&python; Scripts</title>

   <para>
    You can import a &python; script, which will appear in your data
    file as a <link linkend="python-script">script packet</link>.
   </para>
   <para>
    Script packets can include pre-set <emphasis>variables</emphasis>
    that reference other packets in your data file.
    If the imported file begins with a specially
    formatted comment block, &regina; will recognise this and set
    variables in your script packet accordingly.
    This comment block will be written automatically when you
    <link linkend="export-pyscript">export a script packet</link>
    to a &python; file.
    The special comment block is used only for setting variables, and will
    not appear in the code for your new script packet.
   </para>
   <para>
    An example of such a comment block appears below.
   </para>
   <programlisting>
    ### Regina Script: Homology Summary
    ###
    ### Variable tri: Triangulations
    ###
    ### Begin Script

    # See the users' handbook for more elaborate sample Python
    # sessions.

    # Output the homology of each triangulation.
    t = tri.getFirstTreeChild()
    while t != None:
        print t.getPacketLabel() + ":", t.getHomologyH1()
        t = t.getNextTreeSibling()
   </programlisting>
   <para>
    The comment block must appear at the very beginning
    of the file, and each line must begin with three hashes
    (<literal>###</literal>).  A line of the form
    &ldquo;<literal>###&nbsp;Regina&nbsp;Script:&nbsp;<replaceable>label</replaceable></literal>&rdquo;
    suggests to &regina; a <link linkend="import-label">default label</link>
    for your new packet.
    Each line of the form
    &ldquo;<literal>###&nbsp;Variable&nbsp;<replaceable>name</replaceable>:&nbsp;<replaceable>value</replaceable></literal>&rdquo;
    tells &regina; to add the variable <replaceable>name</replaceable>
    to the new script packet, and to make it refer to the packet
    in your data file named <replaceable>value</replaceable>.
   </para>
   <para>
    If the script contains any international characters, you must
    specify the text encoding (such as &utf8; or &latin1;) when
    you choose the file to import.
    A drop-down list of encodings should appear in the file dialog,
    as illustrated below.
   </para>
   <para>
    <inlinemediaobject>
     <imageobject>
      <imagedata fileref="i18n-import.png"/>
     </imageobject>
    </inlinemediaobject>
   </para>
  </sect2>
 </sect1>

 <sect1 id="foreign-export">
  <title>Exporting</title>

  <para>
   An <firstterm>export</firstterm> means that data from the current
   working packet tree is written to a foreign file format.  Generally
   only some of the data from the current tree is exported (e.g., a
   single packet or perhaps a subtree).  All exports are done through the
   <menuchoice>
    <guimenu>File</guimenu>
    <guisubmenu>Export</guisubmenu>
   </menuchoice>
   menu, with each item in this menu representing a different file format.
  </para>
  <para>
   <inlinemediaobject>
    <imageobject>
     <imagedata fileref="menu-export.png"/>
    </imageobject>
   </inlinemediaobject>
  </para>
  <para>
   To export a single packet or a subtree, first select the appropriate file
   format from the
   <menuchoice>
    <guimenu>File</guimenu>
    <guisubmenu>Export</guisubmenu>
   </menuchoice>
   menu.  The following steps will then occur.
  </para>
  <itemizedlist>
   <listitem>
    <para>
     You will be asked which packet to export.
    </para>
    <para>
     <inlinemediaobject>
      <imageobject>
       <imagedata fileref="export-snappea.png"/>
      </imageobject>
     </inlinemediaobject>
    </para>
    <para>
     Whether you are exporting a single packet or an entire subtree
     depends upon the chosen file format.  For example,
     when exporting to a &snappea; triangulation file you use just a single
     packet, whereas when exporting to a &regina; data file you write the
     chosen packet along with all of its descendants.
    </para>
    <para>
     The selection of packets to choose from may be restricted
     according to the chosen export type.  For instance, when exporting
     to a &snappea; triangulation file you may only choose from the
     triangulation packets, and when exporting to a &python; file you
     may only choose from the script packets.
    </para>
   </listitem>
   <listitem>
    <para>
     You will be asked to choose a filename for the exported data.
    </para>
   </listitem>
  </itemizedlist>
  <para>
   &regina; is able to export data to the following file formats:
  </para>

  <sect2 id="export-rga">
   <title>&regina; Data Files</title>

   <para>
    This is &regina;'s native file format, in which data is saved as
    compressed &xml;.  The advantage of exporting to a &regina; data
    file is that you can choose to export only a subtree of the current
    working file.  This is therefore a convenient way of extracting a
    small portion of a larger data file.
   </para>
   <para>
    The packet that is selected for export will become the root of the
    new packet tree.  All of its descendants will be exported also.
   </para>

   <para>TODO: &regina; Data Files (Uncompressed)</para>

   <para>
    This export is identical to the
    <link linkend="export-rga">&regina; data file</link> described
    above, except that the &xml; output is not compressed.  This means
    that the exported data is a plain text file that can be viewed in an
    ordinary text editor.  If you are brave, you can even edit the
    &xml; yourself; see the <link linkend="dataformat">file format
    reference</link> for details.
   </para>
   <para>
    Note that &regina; can happily load both compressed and uncompressed
    &xml; data files.  That is, the exported data file can be opened in the
    usual way through the
    <menuchoice>
     <guimenu>File</guimenu>
     <guimenuitem>Open</guimenuitem>
    </menuchoice>
    menu item.
   </para>
   <para>
    Instead of using the export feature, an alternative
    way of viewing the &xml; content of a native (compressed)
    data file is to pipe it through <command>gunzip</command>:
   </para>
<screen>
    <prompt>example$</prompt> <userinput>cat file.rga | gunzip</userinput>
</screen>
  </sect2>

  <sect2 id="export-snappea">
   <title>&snappea; Triangulations</title>

   <para>
    This allows a single triangulation to be exported to &snappea;'s
    native triangulation file format.  This is a plain text format,
    described in more detail in the earlier section on
    <link linkend="import-snappea">&snappea; imports</link>.
   </para>
   <para>
    Note that a triangulation must satisfy certain constraints before it
    can be exported as a &snappea; triangulation file.  For example, it
    cannot be an <link linkend="tri-propvalid">invalid triangulation</link>,
    and it may not have any boundary faces.
   </para>
   <para>
    Any international characters in the exported &snappea; file will be
    encoded using &utf8;.
   </para>
  </sect2>

  <sect2 id="export-cpp">
   <title>&cpp; Source Code</title>

   <para>
    This allows a single triangulation to be exported as &cpp; source
    code.  The exported source code uses classes and routines from
    &regina;'s calculation engine.  When run, this code will reconstruct
    the original triangulation.
   </para>
   <para>
    Exporting as &cpp; is useful if you wish to hard-code a
    triangulation in your own &cpp; code for further manipulation and/or
    experimentation.  For further information, there is a separate
    chapter on <link linkend="compiling">including the &regina;
    calculation engine in your own code</link>.
   </para>
   <para>
    If the triangulation includes any international characters (for
    instance, in the packet label or the tetrahedron names), these might
    appear as comments in the exported &cpp; code.  You can choose the
    text encoding that will be used for these characters (such as &utf8;
    or &latin1;).  When you are selecting the file to export to, a
    drop-down list of encodings should appear in the dialog, as
    illustrated below.
   </para>
   <para>
    <inlinemediaobject>
     <imageobject>
      <imagedata fileref="i18n-export.png"/>
     </imageobject>
    </inlinemediaobject>
   </para>
  </sect2>

  <sect2 id="export-csvsurfacelist">
   <title>Spreadsheet-Readable (&csv;) Surface Lists</title>

   <para>
    This allows a normal surface list to be exported as a plain-text
    &csv; file (comma-separated values).  &csv; files can be easily
    imported into spreadsheets and databases.
   </para>
   <para>
    The &csv; file will begin with a header row, which will be followed
    by one line for each surface in the list.  Surfaces will be listed
    in standard coordinates (tri-quad coordinates for normal surfaces,
    or tri-quad-oct coordinates for almost normal surfaces), and each
    coordinate will be listed as a separate field in the &csv; file.
   </para>
   <para>
    In addition to the raw coordinates, the &csv; file will include
    several additional properties of the normal surfaces, such as
    Euler characteristic and orientability (amongst others).  These
    additional fields mirror the properties that are displayed on
    screen when viewing a normal surface; see the notes on
    <link linkend="surfaces-coords-props">normal surface properties</link>
    for details.
   </para>
   <para>
    If any of the surfaces have been given names that include
    international characters, these will be encoded in &utf8;
    in the exported &csv; file.
   </para>
  </sect2>

  <sect2 id="export-pdf">
   <title>&pdf; Documents</title>

   <para>
    This allows a single &pdf; packet to be exported as an ordinary
    &pdf; file.  You can then open this file in any regular &pdf; viewer.
   </para>
  </sect2>

  <sect2 id="export-pyscript">
   <title>&python; Scripts</title>

   <para>
    This allows a single script packet to be exported as a regular &python;
    script file.  A special comment block will be added to the beginning
    of this script file describing the packet label and the script
    variables.  This special comment block is described in more detail in the
    earlier section on <link linkend="import-pyscript">&python; imports</link>.
   </para>
   <para>
    If the script contains any international characters, you may choose
    how these will be encoded in the exported &python; script.  When you
    select the file to export to, a drop-down list of encodings should
    appear in the dialog, as illustrated in the &cpp; source section above.
   </para>
  </sect2>
 </sect1>
</chapter>
