<chapter id="foreign">
 <title>Importing and Exporting Data</title>

 <para>
  By default, &regina; reads and writes data files using compressed
  &xml; (these are the usual <filename>.rga</filename> data files).
  However, &regina; is also able to read from and write to a variety
  of alternative file formats, as described in the following sections.
 </para>

 <sect1 id="foreign-import">
  <title>Importing</title>

  <para>
   An <firstterm>import</firstterm> means that data is read from a
   foreign file format and inserted into the current working packet
   tree.  All imports are done through the
   <menuchoice>
    <guimenu>File</guimenu>
    <guisubmenu>Import</guisubmenu>
   </menuchoice>
   menu.  Each item in this menu represents a different file format.
  </para>
  <note><para>
   You must already have a working data file open before you can perform
   an import.  This is because the imported data must be inserted into
   an existing packet tree.
  </para></note>
  <para>
   To import data from a foreign file format, you must choose the
   corresponding menu item in the
   <menuchoice>
    <guimenu>File</guimenu>
    <guisubmenu>Import</guisubmenu>
   </menuchoice>
   menu.  The following steps will then occur.
  </para>
  <itemizedlist>
   <listitem>
    <para>
     You will be asked to select a specific data file to import.
    </para>
   </listitem>
   <listitem>
    <para>
     You will be asked how this new data should be inserted into the
     current packet tree.  The imported data will appear as a new packet
     (or perhaps as a new subtree).  In particular, you will be asked the
     following.
    </para>
    <glosslist>
     <glossentry>
      <glossterm><guilabel>Import beneath:</guilabel></glossterm>
      <glossdef>
       <para>
        You must select a parent packet in the current working packet
        tree.  The imported data will be inserted beneath this parent
        packet.
       </para>
      </glossdef>
     </glossentry>
     <glossentry>
      <glossterm><guilabel>Label:</guilabel></glossterm>
      <glossdef>
       <para>
        You must choose a label for the new packet containing the
        imported data.  The import dialog may offer a reasonable suggestion
        based on the contents of the imported data file.
       </para>
      </glossdef>
     </glossentry>
    </glosslist>
   </listitem>
  </itemizedlist>
  <para>
   &regina; is able to import data from files of the following types:
  </para>

  <sect2 id="import-regina">
   <title>&regina; Data File</title>

   <para>
    The contents of a native &regina; data file can be imported.  In
    this case, the packet tree from the imported file will be
    inserted into the packet tree of the current working file.
   </para>
   <para>
    Importing a &regina; data file is therefore a convenient way of
    merging two data files into one.  See also the
    <link linkend="man-regconcat"><command>regconcat</command></link>
    utility for a way of doing this from the command-line.
   </para>
  </sect2>

  <sect2 id="import-snappea">
   <title>&snappea; Triangulation</title>

   <para>
    A triangulation obtained from &snappea; can be imported.
    &snappeaurl; is the excellent software by Jeffrey Weeks for studying
    hyperbolic 3-manifolds, and is also discussed in the section on
    <link linkend="tri-snappea">&snappea; calculations</link>.
   </para>
   <para>
    The file should be a plain text file in &snappea;'s triangulation
    format; an example is shown below.
    Any international characters should be encoded in &utf8;.
   </para>
   <programlisting>
    % Triangulation
    m002
    geometric_solution  2.02988321
    nonorientable_manifold
    CS_unknown

    0 2
        Klein   0.000000000000   0.000000000000
        Klein   0.000000000000   0.000000000000

    2
       1    1    1    1
     0132 3120 2130 3102
       0    1    0    0
      0  0  0  0  0  0  1 -1  0  0  0  0  1 -1  0  0
      0  1 -1  0  0  0  0  0 -1  0  0  1  0  0  0  0
      0  0  1 -1 -1  0  1  0  1  0  0 -1 -1  1  0  0
      0  0  1 -1 -1  0  1  0  1  0  0 -1 -1  1  0  0
      0.500000000000   0.866025403784

       0    0    0    0
     0132 3120 2130 3102
       0    1    0    0
      0  1 -1  0  0  0  0  0 -1  0  0  1  0  0  0  0
      0  0  0  0  0  0  1 -1  0  0  0  0  1 -1  0  0
      0 -1  1  0  1  0  0 -1  1  0  0 -1 -1  0  1  0
      0 -1  1  0  1  0  0 -1  1  0  0 -1 -1  0  1  0
      0.500000000000   0.866025403784
   </programlisting>
  </sect2>

  <sect2 id="import-orb">
   <title>&orbcasson; Triangulation</title>

   <para>
    A triangulation in &orbcasson; format can be imported.
    &orburl; is a variant of &snappea; for calculating hyperbolic
    structures on 3-orbifolds and 3-manifolds, written by Damien Heard.
   </para>
   <para>
    The file should be a plain text file in &orbcasson; format, which
    describes a triangulation in terms of its 1-skeleton.  The beginning
    of such a file is illustrated below.
    Any international characters should be encoded in &utf8;.
   </para>
   <programlisting>
    % orb
    8knot
    1  0  1.000  1vu  2uw  1ux  2xv  1xw  2vu
    2  0  1.000  1wu  2wx  1xv  2xu  1vw  2vw

    ...
   </programlisting>
  </sect2>

  <sect2 id="import-dehydrationlist">
   <title>Dehydrated Triangulation List</title>

   <para>
    A list of dehydrated triangulation strings can be imported.
    A <firstterm>dehydration string</firstterm> is a set of letters such as
    <literal>dadbcccaqhx</literal> containing enough information to
    recreate the triangulation.  Dehydration strings appear in
    census papers such as the hyperbolic cusped census of
    Callahan, Hildebrand and Weeks <xref linkend="bib-cuspedcensus"/>,
    in which the dehydration format is explicitly described.
   </para>
   <para>
    The list should be stored in a plain text file with one triangulation
    per line.  Each line may contain an arbitrary amount of data, but the
    first word of each line should be the dehydrated triangulation
    string.  A sample file is shown below.
   </para>
   <programlisting>
    dafbcccaadl   N3,1   Z/3 + Z
    dadcbccdjkd   N3,2   Z
    dadbcccbbcv   N3,3   Z
    dadbcccccdm   N3,4   Z
    dadbcccaqhx   N3,5   Z/2 + Z/2 + Z
   </programlisting>
   <para>
    When importing a dehydrated triangulation list, each individual
    triangulation will be rehydrated and inserted beneath a common
    container packet, which will then be inserted into the current
    packet tree.  If you just wish to rehydrate a single triangulation
    string (not many), it may be simpler to use the
    <link linkend="tri-new-dehydration">New Triangulation</link> dialog
    instead.
   </para>
  </sect2>

  <sect2 id="import-pdf">
   <title>&pdf; Document</title>

   <para>
    Any &pdf; document can be imported directly into the packet tree.
    This allows users to document their work with formulae, diagrams and
    anything else that can appear on the printed page.
   </para>
   <para>
    Because all &pdf; packets must be created externally (such as in
    &latex;, or some other typesetting system or word processor), the
    <menuchoice>
     <guimenu>Packet Tree</guimenu>
     <guimenuitem>New PDF Document</guimenuitem>
    </menuchoice>
    menu item brings up exactly the same import dialog as
    <menuchoice>
     <guimenu>File</guimenu>
     <guisubmenu>Import</guisubmenu>
     <guimenuitem>PDF Document</guimenuitem>
    </menuchoice>.
   </para>
  </sect2>

  <sect2 id="import-pyscript">
   <title>&python; Script</title>

   <para>
    An arbitrary &python; script can be imported, in which case it will
    be inserted into the working packet tree as a new script packet.
   </para>
   <para>
    Recall that a script packet may have associated variables that
    reference other packets in the packet tree.  If the
    imported &python; file begins with a specially formatted comment block,
    it can direct &regina; to include certain variables in the new script
    packet (and also suggest a default label for the new script packet).
   </para>
   <para>
    An example of such a comment block is shown below.
   </para>
   <programlisting>
    ### Regina Script: Homology Summary
    ###
    ### Variable tri: Triangulations
    ###
    ### Begin Script

    # See the users' handbook for more elaborate sample Python
    # sessions.

    # Output the homology of each triangulation.
    t = tri.getFirstTreeChild()
    while t != None:
        print t.getPacketLabel() + ":", t.getHomologyH1()
        t = t.getNextTreeSibling()
   </programlisting>
   <para>
    The comment block must appear at the very beginning
    of the file, with each line beginning with three hashes
    (<literal>###</literal>).  A suggested packet label is indicated
    with a line of the form
    <literal>###&nbsp;Regina&nbsp;Script:&nbsp;<replaceable>label</replaceable></literal>.
    Each variable is listed in a line of the form
    <literal>###&nbsp;Variable&nbsp;<replaceable>name</replaceable>:&nbsp;<replaceable>value</replaceable></literal>,
    where <replaceable>name</replaceable> is the name of the script
    variable and <replaceable>value</replaceable> is the label of the
    packet that it should represent.
   </para>
   <para>
    Note that this comment block will not appear in the code section of
    the new script packet.  That is, &regina; will read in the suggested
    packet label, make the requested variable assignments and then throw
    the entire comment block away.
   </para>
   <note><para>
    When <link linkend="export-pyscript">exporting a script
    packet</link> to a &python; file, a comment block such as this will
    be automatically added.
   </para></note>
   <para>
    If the script contains any international characters, you must
    specify the text encoding used (such as &utf8; or &latin1;).
    When you are selecting the file to an import, a drop-down list of
    encodings should appear in the dialog, as illustrated below.
   </para>
   <para>
    <inlinemediaobject>
     <imageobject>
      <imagedata fileref="i18n-import.png"/>
     </imageobject>
    </inlinemediaobject>
   </para>
  </sect2>
 </sect1>

 <sect1 id="foreign-export">
  <title>Exporting</title>

  <para>
   An <firstterm>export</firstterm> means that data from the current
   working packet tree is written to a foreign file format.  Generally
   only some of the data from the current tree is exported (e.g., a
   single packet or perhaps a subtree).  All exports are done through the
   <menuchoice>
    <guimenu>File</guimenu>
    <guisubmenu>Export</guisubmenu>
   </menuchoice>
   menu, with each item in this menu representing a different file format.
  </para>
  <para>
   To export a single packet or a subtree, first select the appropriate file
   format from the
   <menuchoice>
    <guimenu>File</guimenu>
    <guisubmenu>Export</guisubmenu>
   </menuchoice>
   menu.  The following steps will then occur.
  </para>
  <itemizedlist>
   <listitem>
    <para>
     You will be asked which packet to export.
    </para>
    <para>
     Whether you are exporting a single packet or an entire subtree
     depends upon the chosen file format.  For example,
     when exporting to a &snappea; triangulation file you use just a single
     packet, whereas when exporting to a &regina; data file you write the
     chosen packet along with all of its descendants.
    </para>
    <para>
     The selection of packets to choose from may be restricted
     according to the chosen export type.  For instance, when exporting
     to a &snappea; triangulation file you may only choose from the
     triangulation packets, and when exporting to a &python; file you
     may only choose from the script packets.
    </para>
   </listitem>
   <listitem>
    <para>
     You will be asked to choose a filename for the exported data.
    </para>
   </listitem>
  </itemizedlist>
  <para>
   &regina; is able to export data to the following file formats:
  </para>

  <sect2 id="export-rga">
   <title>&regina; Data File</title>

   <para>
    This is &regina;'s native file format, in which data is saved as
    compressed &xml;.  The advantage of exporting to a &regina; data
    file is that you can choose to export only a subtree of the current
    working file.  This is therefore a convenient way of extracting a
    small portion of a larger data file.
   </para>
   <para>
    The packet that is selected for export will become the root of the
    new packet tree.  All of its descendants will be exported also.
   </para>
  </sect2>

  <sect2 id="export-rga-plain">
   <title>&regina; Data File (Uncompressed)</title>

   <para>
    This export is identical to the
    <link linkend="export-rga">&regina; data file</link> described
    above, except that the &xml; output is not compressed.  This means
    that the exported data is a plain text file that can be viewed in an
    ordinary text editor.  If you are brave, you can even edit the
    &xml; yourself; see the <link linkend="dataformat">file format
    reference</link> at the end of this manual.
   </para>
   <para>
    Note that &regina; can happily load both compressed and uncompressed
    &xml; data files.  That is, the exported data file can be opened in the
    usual way through the
    <menuchoice>
     <guimenu>File</guimenu>
     <guimenuitem>Open</guimenuitem>
    </menuchoice>
    menu item.
   </para>
   <para>
    Instead of using the export feature, an alternative
    way of viewing the &xml; content of a native (compressed)
    data file is to pipe it through <command>gunzip</command>:
   </para>
<screen>
    <prompt>example$</prompt> <userinput>cat file.rga | gunzip</userinput>
</screen>
  </sect2>

  <sect2 id="export-snappea">
   <title>&snappea; Triangulation</title>

   <para>
    This allows a single triangulation to be exported to &snappea;'s
    native triangulation file format.  This is a plain text format,
    described in more detail in the earlier section on
    <link linkend="import-snappea">&snappea; imports</link>.
   </para>
   <para>
    Note that a triangulation must satisfy certain constraints before it
    can be exported as a &snappea; triangulation file.  For example, it
    cannot be an <link linkend="tri-propvalid">invalid triangulation</link>,
    and it may not have any boundary faces.
   </para>
   <para>
    Any international characters in the exported &snappea; file will be
    encoded using &utf8;.
   </para>
  </sect2>

  <sect2 id="export-cpp">
   <title>&cpp; Source</title>

   <para>
    This allows a single triangulation to be exported as &cpp; source
    code.  The exported source code uses classes and routines from
    &regina;'s calculation engine.  When run, this code will reconstruct
    the original triangulation.
   </para>
   <para>
    Exporting as &cpp; is useful if you wish to hard-code a
    triangulation in your own &cpp; code for further manipulation and/or
    experimentation.  For further information, there is a separate
    chapter on <link linkend="compiling">including the &regina;
    calculation engine in your own code</link>.
   </para>
   <para>
    If the triangulation includes any international characters (for
    instance, in the packet label or the tetrahedron names), these might
    appear as comments in the exported &cpp; code.  You can choose the
    text encoding that will be used for these characters (such as &utf8;
    or &latin1;).  When you are selecting the file to export to, a
    drop-down list of encodings should appear in the dialog, as
    illustrated below.
   </para>
   <para>
    <inlinemediaobject>
     <imageobject>
      <imagedata fileref="i18n-export.png"/>
     </imageobject>
    </inlinemediaobject>
   </para>
  </sect2>

  <sect2 id="export-csvsurfacelist">
   <title>&csv; Surface List</title>

   <para>
    This allows a normal surface list to be exported as a plain-text
    &csv; file (comma-separated values).  &csv; files can be easily
    imported into spreadsheets and databases.
   </para>
   <para>
    The &csv; file will begin with a header row, which will be followed
    by one line for each surface in the list.  Surfaces will be listed
    in standard coordinates (tri-quad coordinates for normal surfaces,
    or tri-quad-oct coordinates for almost normal surfaces), and each
    coordinate will be listed as a separate field in the &csv; file.
   </para>
   <para>
    In addition to the raw coordinates, the &csv; file will include
    several additional properties of the normal surfaces, such as
    Euler characteristic and orientability (amongst others).  These
    additional fields mirror the properties that are displayed on
    screen when viewing a normal surface; see the notes on
    <link linkend="surfaces-viewsurfaceprops">normal surface properties</link>
    for details.
   </para>
   <para>
    If any of the surfaces have been given names that include
    international characters, these will be encoded in &utf8;
    in the exported &csv; file.
   </para>
  </sect2>

  <sect2 id="export-pdf">
   <title>&pdf; Document</title>

   <para>
    This allows a single &pdf; packet to be exported as an ordinary
    &pdf; file.  You can then open this file in any regular &pdf; viewer.
   </para>
  </sect2>

  <sect2 id="export-pyscript">
   <title>&python; Script</title>

   <para>
    This allows a single script packet to be exported as a regular &python;
    script file.  A special comment block will be added to the beginning
    of this script file describing the packet label and the script
    variables.  This special comment block is described in more detail in the
    earlier section on <link linkend="import-pyscript">&python; imports</link>.
   </para>
   <para>
    If the script contains any international characters, you may choose
    how these will be encoded in the exported &python; script.  When you
    select the file to export to, a drop-down list of encodings should
    appear in the dialog, as illustrated in the &cpp; source section above.
   </para>
  </sect2>
 </sect1>
</chapter>
