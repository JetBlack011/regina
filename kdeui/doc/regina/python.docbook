<chapter id="python">
 <title>&python; Scripting</title>

 <sect1 id="python-overview">
  <title>Scripting Overview</title>
  <para>
   &regina; contains inbuilt scripting, which offers you fine control
   over the underlying calculation engine and enables you to automate
   large amounts of processing using the &python;
   programming language.  Scripts can be written and run from within
   &regina;, and a well-written script can relieve you of much work
   that would otherwise have to be painstakingly done by hand
   through the point-and-click interface.
  </para>

  <sect2 id="python-invoking">
   <title>Invoking Scripting</title>
   <para>
    Scripting is available by several means.
    <itemizedlist>
     <listitem><para>
      You can run the command-line program
      <link linkend="man-regina-python"><command>regina-python</command></link>
      without using the graphical user interface at all.
      This uses the standard &python; command-line interpreter and is
      quite fast.
      Since it is purely text based, it also supports the redirection of
      input and output.
     </para></listitem>
     <listitem><para>
      You can bring up a graphical &python; console through the
      <menuchoice>
       <guimenu>Tools</guimenu>
       <guimenuitem>Python Console</guimenuitem>
      </menuchoice>
      menu item or the corresponding toolbar button.
      The top-level packet of the current file (if any) will be assigned
      to the special variable <varname>root</varname>.
      The currently selected packet (if any) will be assigned to the
      special variable <varname>selected</varname>.
     </para></listitem>
     <listitem>
      <para>
       You can create a new <link linkend="packet-script">script
       packet</link>.  Script packets have the advantage that they
       can work seamlessly with multiple packets in the
       same file through the use of script variables.
       Furthermore, script packets are saved with the data file for later reuse.
      </para>
      <para>
       The editor for script packets includes a table of variables that will be
       set each time the script is run.  Buttons and menu options are
       available for running the script or for simply testing whether
       it compiles.
      </para>
      <para>
       Each time a script is run, a new graphical &python; console is opened.
       The script is run within this console and the console is then
       made available to the user for further interaction.
      </para>
     </listitem>
    </itemizedlist>
   </para>
  </sect2>

  <sect2 id="python-python">
   <title>Using &python;</title>
   <para>
    All scripts use the &python; scripting language
    (<ulink url="http://www.python.org/"/>).
    Within these scripts, &regina; objects, classes and methods can be
    accessed directly as if they were &python; objects, classes and methods.
   </para>
   <para>
    Each of these objects, classes and methods is available in the
    module <parameter>regina</parameter>.  For instance, a new
    triangulation can be created by calling
    <literal>regina.NTriangulation()</literal> and a file can be
    read by calling <literal>regina.readFileMagic(filename)</literal>.
   </para>
   <para>
    Wherever &regina; gives you access to &python;, you may assume that the
    <parameter>regina</parameter> module has been imported (thus giving you
    access to everything contained within it).
    You may also assume that all user libraries have been loaded, as
    described below.
   </para>
   <tip>
    <para>
     If you have code that you find yourself writing again and again,
     you can put it in a <firstterm>user library</firstterm>.  User
     libraries are files containing &python; code (typically function
     definitions) that is run at the beginning of every &python;
     session, both within the &gui; and within the text-based
     <link linkend="man-regina-python"><command>regina-python</command></link>.
     The list of user libraries can be configured through the
     <link linkend="python-libraries">&python; options</link> page, or can be
     maintained by hand-editing the file &regina-libs; as described in the
     <link linkend="man-regina-python"><command>regina-python</command></link>
     reference.
    </para>
   </tip>
  </sect2>

  <sect2 id="python-docs">
   <title>Documentation</title>
   <para>
    &regina; includes a complete reference for its calculation engine,
    which describes in detail the objects, classes and methods made available
    to &python; scripts.  This documentation is available through the
    <menuchoice>
     <guimenu>Help</guimenu>
     <guimenuitem>Python Reference</guimenuitem>
    </menuchoice>
    menu item.
   </para>
   <para>
    For those wishing to read this documentation from outside the
    program, it is generally installed in
    <filename>/usr/share/regina/engine-docs/</filename>
    or <filename>/usr/local/share/regina/engine-docs/</filename>, although this
    may differ with your distribution or installation.
   </para>
  </sect2>
 </sect1>

 <sect1 id="python-caveats">
  <title>Caveats</title>

  <para>
   &python; scripting offers direct access to the mathematical core of the
   software, and as such requires a little care &ndash; in general
   the user interface has no way of knowing what you are tinkering with.
   Probably the easiest way to crash the program is to bring up
   a &python; console and do something untoward.
   Thus you should tread gently.
  </para>
  <para>
   The following issues in particular are worth being aware of.
  </para>
  <sect2 id="python-gui">
   <title>Cooperating with the &gui;</title>
   <para>
    If you cannot edit a packet from within the GUI, there is generally
    a reason for this.  For instance, a normal surface list will rely
    upon its parent triangulation remaining fixed and so any
    triangulation with child surface lists will be uneditable.
   </para>
   <para>
    Therefore you should not use &python; as a
    way to get around that barrier; instead you should respect that
    barrier.  Perhaps you can <link linkend="packet-clone">clone the
    packet</link> in question without cloning its subtree (<menuchoice>
     <guimenu>Packet Tree</guimenu>
     <guimenuitem>Clone Packet</guimenuitem>
    </menuchoice>); the clone then should be editable.
   </para>
  </sect2>

  <sect2 id="python-ownership">
   <title>Ownership Concerns</title>

   <para>
    A small handful of routines have unusual ownership semantics, in
    that one or more arguments to these routines transfer ownership of
    themselves to some other object.  The most prominent examples are the
    tree insertion routines
    <function>NPacket.insertChildFirst()</function>,
    <function>NPacket.insertChildLast()</function> and
    <function>NPacket.insertChildAfter()</function>.
   </para>
   <para>
    As an example, suppose that <varname>p</varname> is a new
    packet created within a &python; console.  In this case the console
    itself owns <varname>p</varname>, and when the console is
    destroyed <varname>p</varname> will be destroyed along with
    it.  However, if <varname>p</varname> is inserted as a child
    of some other packet using <literal>other.insertChildLast(p)</literal>,
    ownership of <varname>p</varname> is transferred to its new
    parent <varname>other</varname>.
   </para>
   <para>
    Due to a constraint of &boost-python;, whenever ownership of an
    object is transferred away from the &python; console, the old
    reference to that object becomes no longer valid.  In the above example,
    further attempts to use the object <varname>p</varname> will result
    in an ugly &python; error.  Depending on your system configuration,
    this might be either a <exceptionname>TypeError</exceptionname>
    or a <exceptionname>Boost.Python.ArgumentError</exceptionname>.
   </para>
   <para>
    Either way, in the example above the value of
    <varname>p</varname> can be easily restored by calling
    <literal>p = other.getLastTreeChild()</literal>.  After doing this,
    the console now treats <varname>p</varname> as a reference to some
    external object that it has no direct responsibility over (which is indeed
    what you want, since <varname>other</varname> is now looking after it).
   </para>
   <para>
    In practice the only cases in which this problem arises are with
    the tree insertion routines listed above and one or two others
    (such as <function>NGroupPresentation.addRelation()</function>).
   </para>
   <para>
    An example of the <exceptionname>TypeError</exceptionname> described
    above can be seen in the following extract from a &python; session.
   </para>
   <programlisting>
&gt;&gt;&gt; c = regina.NContainer()
&gt;&gt;&gt; t = regina.NTriangulation()
&gt;&gt;&gt; c.insertChildLast(t)
&gt;&gt;&gt; print c
Container
&gt;&gt;&gt; print t

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: bad argument type for built-in operation
&gt;&gt;&gt; t = c.getLastTreeChild()
&gt;&gt;&gt; print t
Triangulation with 0 tetrahedra.
&gt;&gt;&gt;
</programlisting>
   <para>
    The following example shows the same set of commands run on a system
    that issues a <exceptionname>Boost.Python.ArgumentError</exceptionname>
    instead.
   </para>
<programlisting>
&gt;&gt;&gt; c = regina.NContainer()
&gt;&gt;&gt; t = regina.NTriangulation()
&gt;&gt;&gt; c.insertChildLast(t)
&gt;&gt;&gt; print c
Container
&gt;&gt;&gt; print t
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
Boost.Python.ArgumentError: Python argument types in
    ShareableObject.__str__(NTriangulation)
did not match C++ signature:
    __str__(regina::ShareableObject {lvalue})
&gt;&gt;&gt; t = c.getLastTreeChild()
&gt;&gt;&gt; print t
Triangulation with 0 tetrahedra.
&gt;&gt;&gt;
</programlisting>
  <tip>
   <para>
    Although it does not help with the example above (inserting a brand new
    packet into the tree), the routine
    <function>NPacket.reparent()</function> makes it easy to avoid ownership
    problems when moving a packet from one place in a tree to another.
   </para>
   <para>
    The troublesome way of doing this is to call
    <function>makeOrphan()</function> followed by an insertion routine
    such as <function>insertChildFirst()</function>, which causes the
    problems described above.  The following example tries to move the
    packet <varname>child</varname> from the old parent
    <varname>p1</varname> to the new parent <varname>p2</varname>:
   </para>
<programlisting>
&gt;&gt;&gt; ...
&gt;&gt;&gt; child = p1.getFirstTreeChild()
&gt;&gt;&gt; child.makeOrphan()
&gt;&gt;&gt; p2.insertChildLast(child)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
Boost.Python.ArgumentError: ...
</programlisting>
   <para>
    A better way of doing this is to use a single call to
    <function>reparent()</function>, which works flawlessly:
   </para>
<programlisting>
&gt;&gt;&gt; ...
&gt;&gt;&gt; child = p1.getFirstTreeChild()
&gt;&gt;&gt; child.reparent(p2)
&gt;&gt;&gt; print child
Triangulation with 2 tetrahedra.
&gt;&gt;&gt; print p2.getLastTreeChild()
Triangulation with 2 tetrahedra.
&gt;&gt;&gt;
</programlisting>
  </tip>
  </sect2>

  <sect2 id="python-i18n">
   <title>International Characters</title>
   <para>
    As of version &utf8intro;, &regina; uses &utf8; consistently for
    international characters throughout its calculation engine.  If you ever
    pass a string into one of &regina;'s functions, you must ensure that it
    is encoded in &utf8;; conversely, when a string is returned from a
    function you should assume it is encoded in &utf8;.
   </para>
   <para>
    This is important for &python; users to be aware of, since &python;
    strings do not use &utf8; by default.  It is hoped that future
    versions of &regina; can make conversions between &python; strings
    and &utf8; strings more transparent.
   </para>
   <para>
    As a single exception, file <emphasis>names</emphasis> should be in
    whatever encoding the operating system expects; these will be passed
    through to low-level &ccpp; file I/O routines without any changes or
    re-encoding.
   </para>
   <tip><para>
    Users who only ever deal with plain &ascii; text do not need to
    worry about text encodings at all, since plain &ascii; is a subset
    of &utf8;.
   </para></tip>
  </sect2>
 </sect1>

 <sect1 id="sessions">
  <title>Sample &python; Sessions</title>
  <para>
   Reproduced below are a number of sample &python; sessions.
   Each session was started by running
   <userinput>regina-python</userinput>
   from the command line.
  </para>

  <sect2 id="sessiontriangulation">
   <title>Working with a triangulation</title>
   <programlisting>&sessiontriangulation;</programlisting>
  </sect2>

  <sect2 id="sessiontree">
   <title>Working with a packet tree</title>
   <programlisting>&sessiontree;</programlisting>
  </sect2>

  <sect2 id="sessionprogress">
   <title>Reporting progress of long operations</title>
   <programlisting>&sessionprogress;</programlisting>
  </sect2>
 </sect1>
</chapter>
