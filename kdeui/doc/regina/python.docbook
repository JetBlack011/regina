<chapter id="python">
 <title>&python; Scripting</title>

 <para>
  &regina; contains inbuilt scripting, which offers you fine control
  over &regina;'s mathematical engine and enables you to automate
  large amounts of processing.
  You can write and run scripts from
  directly within &regina;, or you can use the separate command-line tool
  <link linkend="man-regina-python"><command>regina-python</command></link>.
 </para>
 <para>
  The user interface will stay in sync with any changes that you
  make through a script, which means you can happily modify a
  data file via scripts while you have it open.
 </para>
 <para>
  All scripts in &regina; use the &python; programming language
  (<ulink url="http://www.python.org/"/>).
 </para>

 <sect1 id="python-starting">
  <title>Starting a &python; Session</title>
  <para>
   There are several ways of starting a &python; session to work with
   &regina;:
  </para>

  <sect2 id="python-gui">
   <title>Graphical &python; Consoles</title>
   <para>
    You can open a graphical &python; console by selecting
    <menuchoice>
     <guimenu>Tools</guimenu>
     <guimenuitem>Python Console</guimenuitem>
    </menuchoice>
    from the menu (or by pressing the corresponding toolbar button).
   </para>
   <para>
    <inlinemediaobject>
     <imageobject>
      <imagedata fileref="menu-python.png"/>
     </imageobject>
    </inlinemediaobject>
   </para>
   <para>
    A new console window will open as illustrated below,
    with an input area down the bottom (see the red arrow) and a
    full history of the session in the main part of the window.
    You can save this history by selecting
    <menuchoice>
     <guimenu>Console</guimenu>
     <guimenuitem>Save Session</guimenuitem>
    </menuchoice>.
   </para>
   <para>
    <inlinemediaobject>
     <imageobject>
      <imagedata fileref="python-console.png"/>
     </imageobject>
    </inlinemediaobject>
   </para>
   <para>
    When you start the &python; session, &regina; will set some special
    variables for you:
    <glosslist>
     <glossentry>
      <glossterm><varname>root</varname></glossterm>
      <glossdef><para>
       If you have a data file open,
       the variable <varname>root</varname> will refer to the packet
       at the top of your packet tree.
      </para></glossdef>
     </glossentry>
     <glossentry>
      <glossterm><varname>selected</varname></glossterm>
      <glossdef><para>
       If you have a packet selected in the tree,
       the variable <varname>selected</varname> will refer to this packet
       (see the figure above for an example of this).
      </para></glossdef>
     </glossentry>
    </glosslist>
   </para>
   <para>
    You are welcome to use these variables to change
    packets in your data file (or even add, remove or rename packets):
    the graphical user interface will always stay in sync with any changes
    that you make via &python;.
   </para>
  </sect2>
  <sect2 id="python-cmdline">
   <title>Command-Line Sessions</title>
   <para>
    You can run the command-line program
    <link linkend="man-regina-python"><command>regina-python</command></link>
    without a graphical user interface at all.
    This will use the standard &python; interpreter.
    Since this is a text-based interface, you can also redirect
    input and output in the usual way (using &lt; and &gt; in your
    command shell).
   </para>
   <para>
    <inlinemediaobject>
     <imageobject>
      <imagedata fileref="regina-python.png"/>
     </imageobject>
    </inlinemediaobject>
   </para>
  </sect2>
  <sect2 id="python-script">
   <title>Script Packets</title>
   <para>
    You can create a new <link linkend="packet-script">script
    packet</link> in your data file.  Script packets allow you to save
    &python; scripts along with your data, and they give your scripts
    easy access to the packets inside your file.
   </para>
   <para>
    <inlinemediaobject>
     <imageobject>
      <imagedata fileref="menu-newscript.png"/>
     </imageobject>
    </inlinemediaobject>
   </para>
   <para>
    When you open a script packet, you will see your &python; code in the lower
    part of the script editor, and a table of variables up the top.
   </para>
   <para>
    <inlinemediaobject>
     <imageobject>
      <imagedata fileref="script-edit.png"/>
     </imageobject>
    </inlinemediaobject>
   </para>
   <para>
    You can add your own variables to this table, and set them to arbitrary
    packets within your data file.  &regina; will always set these variables
    to the corresponding packets before running your script.
   </para>
   <para>
    <inlinemediaobject>
     <imageobject>
      <imagedata fileref="script-var.png"/>
     </imageobject>
    </inlinemediaobject>
   </para>
   <para>
    At the top of the script editor you will find buttons to compile
    and run your script.
    Compiling is optional: it merely gives you a chance to spot
    syntax errors as you go.
    When you press <guibutton>Run</guibutton>, &regina; will run your
    script in a new graphical &python; console.
    The console will be left open in case you wish to experiment further.
   </para>
   <para>
    <inlinemediaobject>
     <imageobject>
      <imagedata fileref="script-run.png"/>
     </imageobject>
    </inlinemediaobject>
   </para>
   <para>
    Again, you are welcome to change packets in your data file via
    scripts (or even add, remove or rename packets):
    the graphical user interface will always stay in sync with any changes
    that your scripts make.
   </para>
  </sect2>
 </sect1>

 <sect1 id="python-access">
  <title>Accessing &regina; from &python;</title>
  <para>
   All of &regina;'s objects, classes and methods belong to the
   module called <parameter>regina</parameter>.
   For instance, you can create a new triangulation by calling
   <literal>regina.NTriangulation()</literal>, and you can read a data file
   by calling <literal>regina.readFileMagic(filename)</literal>.
   Whenever &regina; gives you access to &python; (either through a
   <link linkend="python-gui">graphical console</link>,
   a <link linkend="python-script">script packet</link> or a
   <link linkend="python-cmdline">command-line session</link>),
   it will automatically import the <parameter>regina</parameter>
   module for you to use.
  </para>
  <tip>
   <para>
    If you have code that you find yourself writing again and again,
    you can put it in a <firstterm>user library</firstterm>.
    &regina; will run all of the code in all of your user libraries
    at the beginning of every &python; session
    (including graphical consoles, script packets
    and <command>regina-python</command>).
    User libraries are just ordinary &python; files: you can maintain
    the current list of enabled libraries through
    &regina;'s <link linkend="python-libraries">&python; options</link>
    (or if you prefer, through the file &regina-libs; as described in the
    <link linkend="man-regina-python"><command>regina-python</command></link>
    reference).
   </para>
  </tip>

  <sect2 id="python-docs">
   <title>Documentation</title>
   <para>
    &regina; includes a complete &api; reference for its calculation engine,
    which describes in detail the objects, classes and methods that
    it makes available through &python;.  To read this documentation, select
    <menuchoice>
     <guimenu>Help</guimenu>
     <guimenuitem>Python &api; Reference</guimenuitem>
    </menuchoice>
    from the menu.  The &api; reference should open in your web browser
    (where you can bookmark it if you like).
    You can also read it online at &regenginedocsurlbase;.
   </para>
  </sect2>
 </sect1>

 <sect1 id="python-caveats">
  <title>Caveats and Traps</title>

  <para>
   &python; scripting gives you direct access to &regina;'s
   mathematical core, and as such requires some care.
   Probably the easiest way to crash &regina; is to bring up
   a &python; console and do something untoward (like gluing together
   two tetrahedra that belong to different triangulations).
   Please tread gently.
  </para>
  <para>
   In particular, the following issues are worth noting:
  </para>
  <sect2>
   <title>Cooperating with the &gui;</title>
   <para>
    If you cannot edit a packet from within the GUI, there is generally
    a reason for this.  For instance, a normal surface list needs its
    parent triangulation to remain fixed, which means that any
    triangulation with normal surface lists beneath it
    will be <link linkend="packet-uneditable">uneditable</link>.
   </para>
   <para>
    You should not use &python; as a way to get around this barrier.
    In the example above, you can work around the problem by
    <link linkend="packet-clone">cloning the packet</link>
    and editing the clone instead.
   </para>
  </sect2>

  <sect2 id="python-ownership">
   <title>Ownership Concerns</title>

   <para>
    A small handful of routines have unusual ownership semantics, in
    that one or more arguments to these routines transfer ownership of
    themselves to some other object.  The most prominent examples are the
    tree insertion routines
    <function>NPacket.insertChildFirst()</function>,
    <function>NPacket.insertChildLast()</function> and
    <function>NPacket.insertChildAfter()</function>.
   </para>
   <para>
    As an example, suppose that <varname>p</varname> is a new
    packet created within a &python; console.  In this case the console
    itself owns <varname>p</varname>, and when the console is
    destroyed <varname>p</varname> will be destroyed along with
    it.  However, if <varname>p</varname> is inserted as a child
    of some other packet using <literal>other.insertChildLast(p)</literal>,
    ownership of <varname>p</varname> is transferred to its new
    parent <varname>other</varname>.
   </para>
   <para>
    Due to a constraint of &boost-python;, whenever ownership of an
    object is transferred away from the &python; console, the old
    reference to that object becomes no longer valid.  In the above example,
    further attempts to use the object <varname>p</varname> will result
    in an ugly &python; error.  Depending on your system configuration,
    this might be either a <exceptionname>TypeError</exceptionname>
    or a <exceptionname>Boost.Python.ArgumentError</exceptionname>.
   </para>
   <para>
    Either way, in the example above the value of
    <varname>p</varname> can be easily restored by calling
    <literal>p = other.getLastTreeChild()</literal>.  After doing this,
    the console now treats <varname>p</varname> as a reference to some
    external object that it has no direct responsibility over (which is indeed
    what you want, since <varname>other</varname> is now looking after it).
   </para>
   <para>
    In practice the only cases in which this problem arises are with
    the tree insertion routines listed above and one or two others
    (such as <function>NGroupPresentation.addRelation()</function>).
   </para>
   <para>
    An example of the <exceptionname>TypeError</exceptionname> described
    above can be seen in the following extract from a &python; session.
   </para>
   <programlisting>
&gt;&gt;&gt; c = regina.NContainer()
&gt;&gt;&gt; t = regina.NTriangulation()
&gt;&gt;&gt; c.insertChildLast(t)
&gt;&gt;&gt; print c
Container
&gt;&gt;&gt; print t

Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
TypeError: bad argument type for built-in operation
&gt;&gt;&gt; t = c.getLastTreeChild()
&gt;&gt;&gt; print t
Triangulation with 0 tetrahedra.
&gt;&gt;&gt;
</programlisting>
   <para>
    The following example shows the same set of commands run on a system
    that issues a <exceptionname>Boost.Python.ArgumentError</exceptionname>
    instead.
   </para>
<programlisting>
&gt;&gt;&gt; c = regina.NContainer()
&gt;&gt;&gt; t = regina.NTriangulation()
&gt;&gt;&gt; c.insertChildLast(t)
&gt;&gt;&gt; print c
Container
&gt;&gt;&gt; print t
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
Boost.Python.ArgumentError: Python argument types in
    ShareableObject.__str__(NTriangulation)
did not match C++ signature:
    __str__(regina::ShareableObject {lvalue})
&gt;&gt;&gt; t = c.getLastTreeChild()
&gt;&gt;&gt; print t
Triangulation with 0 tetrahedra.
&gt;&gt;&gt;
</programlisting>
  <tip>
   <para>
    Although it does not help with the example above (inserting a brand new
    packet into the tree), the routine
    <function>NPacket.reparent()</function> makes it easy to avoid ownership
    problems when moving a packet from one place in a tree to another.
   </para>
   <para>
    The troublesome way of doing this is to call
    <function>makeOrphan()</function> followed by an insertion routine
    such as <function>insertChildFirst()</function>, which causes the
    problems described above.  The following example tries to move the
    packet <varname>child</varname> from the old parent
    <varname>p1</varname> to the new parent <varname>p2</varname>:
   </para>
<programlisting>
&gt;&gt;&gt; ...
&gt;&gt;&gt; child = p1.getFirstTreeChild()
&gt;&gt;&gt; child.makeOrphan()
&gt;&gt;&gt; p2.insertChildLast(child)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
Boost.Python.ArgumentError: ...
</programlisting>
   <para>
    A better way of doing this is to use a single call to
    <function>reparent()</function>, which works flawlessly:
   </para>
<programlisting>
&gt;&gt;&gt; ...
&gt;&gt;&gt; child = p1.getFirstTreeChild()
&gt;&gt;&gt; child.reparent(p2)
&gt;&gt;&gt; print child
Triangulation with 2 tetrahedra.
&gt;&gt;&gt; print p2.getLastTreeChild()
Triangulation with 2 tetrahedra.
&gt;&gt;&gt;
</programlisting>
  </tip>
  </sect2>

  <sect2 id="python-i18n">
   <title>International Characters</title>
   <para>
    &regina; uses &utf8; consistently for
    international characters.  If you ever
    pass a string into one of &regina;'s functions, you must ensure that it
    is encoded in &utf8;; conversely, when a string is returned from a
    function you should assume it is encoded in &utf8;.
   </para>
   <para>
    This is important for &python; users to be aware of, since &python;
    strings do not use &utf8; by default.  It is hoped that future
    versions of &regina; can make conversions between &python; strings
    and &utf8; strings more transparent.
   </para>
   <para>
    As a single exception, file <emphasis>names</emphasis> should be in
    whatever encoding the operating system expects; these will be passed
    through to low-level &ccpp; file I/O routines without any changes or
    re-encoding.
   </para>
   <para>
    Users who only ever deal with plain &ascii; text do not need to
    worry about text encodings at all, since plain &ascii; is a subset
    of &utf8;.
   </para>
  </sect2>
 </sect1>

 <sect1 id="sessions">
  <title>Sample &python; Sessions</title>
  <para>
   Reproduced below are a number of sample &python; sessions.
   Each session was started by running
   <userinput>regina-python</userinput>
   from the command line.
  </para>

  <sect2 id="sessiontriangulation">
   <title>Working with a triangulation</title>
   <programlisting>&sessiontriangulation;</programlisting>
  </sect2>

  <sect2 id="sessiontree">
   <title>Working with a packet tree</title>
   <programlisting>&sessiontree;</programlisting>
  </sect2>

  <sect2 id="sessionprogress">
   <title>Reporting progress of long operations</title>
   <programlisting>&sessionprogress;</programlisting>
  </sect2>
 </sect1>
</chapter>
