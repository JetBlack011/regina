#!/usr/bin/python
#
# Regina - A Normal Surface Theory Calculator
# Alternate implementations of command-line utilities for the MacOS app bundle
#
# Copyright (c) 2002-2016, Ben Burton
# For further details contact Ben Burton (bab@debian.org).
#
# This implementation is designed for the Xcode bundle only - it hard-codes
# paths to the census databases that are specific to the bundle layout.
# In all other settings, you should use the standard implementations
# of these utilities from the utils/ directory of Regina's source tree.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 2 of the
# License, or (at your option) any later version.
#
# As an exception, when this program is distributed through (i) the
# App Store by Apple Inc.; (ii) the Mac App Store by Apple Inc.; or
# (iii) Google Play by Google Inc., then that store may impose any
# digital rights management, device limits and/or redistribution
# restrictions that are required by its terms of service.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public
# License along with this program; if not, write to the Free
# Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
# MA 02110-1301, USA.

import os
import sys
import string

appName = os.path.basename(sys.argv[0])
appDir = os.path.dirname(sys.argv[0])

def globalUsage(error):
    if error:
        sys.stderr.write('ERROR: ' + error + '\n\n')
    sys.stderr.write('Please call this script through the symlinks provided in the MacOS directory.\n');
    sys.exit(1)

try:
    sys.path = [ appDir + '/python' ] + sys.path
    import regina
except:
    globalUsage('Could not import the regina module.')

regina.NGlobalDirs.setDirs('', '', appDir + '/../Resources')

if appName == 'censuslookup':
    def usage(error):
        if error:
            sys.stderr.write(error + '\n\n')

        sys.stderr.write('Usage:\n')
        sys.stderr.write('    ' + sys.argv[0] + ' <isosig> ...\n')
        sys.exit(1)

    if len(sys.argv) < 2:
        usage('Please specify one or more isomorphism signatures.')

    for sig in sys.argv[1:]:
        hits = regina.NCensus.lookup(sig)

        n = hits.count()
        if n == 1:
            print sig + ': 1 hit'
        else:
            print sig + ':', n, 'hits'

        hit = hits.first()
        while hit:
            print '    ' + hit.name() + ' -- ' + hit.db().desc()
            hit = hit.next()

        print

elif appName == 'regconcat':
    def usage(error):
        if error:
            sys.stderr.write(error + '\n\n')

        sys.stderr.write('Usage:\n')
        sys.stderr.write('    ' + sys.argv[0] + \
            ' [ -o <output-file> ] <data-file> ...\n\n')
        sys.stderr.write('    -o <output-file> : Write to the given data file (otherwise standard\n')
        sys.stderr.write('                       output is used)\n')
        sys.exit(1)

    # Parse the command line.
    files = []
    outputFile = None

    i = 1
    while i < len(sys.argv):
        if sys.argv[i] == '-o':
            if i == len(sys.argv) - 1:
                usage('Option -o is missing an output filename.')
            elif outputFile:
                usage('More than one output filename has been supplied.')
            i = i + 1
            outputFile = sys.argv[i]
        elif sys.argv[i][:1] == '-':
            usage('Invalid option: ' + sys.argv[i])
        elif sys.argv[i]:
            files.append(sys.argv[i])
        else:
            usage('Empty arguments are not allowed.')

        i = i + 1

    if not files:
        usage('No data files have been supplied.')

    # Read the input files one by one.
    ans = regina.NContainer()
    ans.setLabel('Combined Data')

    error = False
    for f in files:
        data = regina.open(f)
        if not data:
            sys.stderr.write('File ' + f + ' could not be read.\n')
            error = True
        else:
            ans.insertChildLast(data)

    # Tidy up the final data file and write it.
    if not outputFile:
        ans.writeXMLFile()
    elif not ans.save(outputFile):
        sys.stderr.write('File ' + outputFile + ' could not be written.\n')

    if error:
        sys.exit(1)

elif appName == 'regconvert':
    def usage(error):
        if error:
            sys.stderr.write(error + '\n\n')

        sys.stderr.write('Usage:\n')
        sys.stderr.write('    ' + sys.argv[0] + ' [ -x | -u ] <old-file> [ <new-file> ]\n\n')
        sys.stderr.write('    -x : Convert to compressed XML (default)\n')
        sys.stderr.write('    -u : Convert to uncompressed XML\n\n')
        sys.stderr.write('    <new-file> may be the same as <old-file>.\n')
        sys.stderr.write('    <new-file> defaults to standard output (implies -u).\n')
        sys.exit(1)

    oldFile = None
    newFile = None
    typeOpt = None

    for arg in sys.argv[1:]:
        if arg == '-u' or arg == '-x':
            if typeOpt:
                usage('More than one file type has been specified.')
            typeOpt = arg[1]
        elif arg[:1] == '-':
            usage('Invalid option: ' + arg)
        elif arg == '':
            usage('Empty arguments are not allowed.')
        elif not oldFile:
            oldFile = arg
        elif not newFile:
            newFile = arg
        else:
            usage('More than two files have been specified.')

    if not oldFile:
        usage('No files have been specified.')

    # Add default options.
    if not typeOpt:
        if newFile:
            typeOpt = 'x'
        else:
            typeOpt = 'u'

    # Check we're allowed to use stdout if we've asked for it.
    if (not newFile) and (typeOpt != 'u'):
        usage('Only uncompressed XML can be written to standard output.')

    # Read the old file.
    tree = regina.open(oldFile)
    if not tree:
        sys.stderr.write('File ' + oldFile + ' could not be read.\n')
        sys.exit(1)

    # Write the new file.
    if not newFile:
        tree.writeXMLFile()
    elif not tree.save(newFile, (typeOpt == 'x')):
        sys.stderr.write('File ' + newFile + ' could not be written.\n')
        sys.exit(1)

elif appName == 'regfiledump':
    def usage(error):
        if error:
            sys.stderr.write(error + '\n\n')

        sys.stderr.write('Usage:\n')
        sys.stderr.write('    ' + sys.argv[0] + ' [ -f | -l | -n ] [ -c ] <file> [ <packet-label> ... ]\n\n')
        sys.stderr.write('    -f : Display full packet details (default)\n')
        sys.stderr.write('    -l : Only display packet labels and types\n')
        sys.stderr.write("    -l : Don't display packets at all (implies -c)\n")
        sys.stderr.write('    -c : Finish with a count of all packets in the file\n\n')
        sys.stderr.write('    <packet-label> ... : Only display the listed packets (otherwise all\n')
        sys.stderr.write('                         packets are displayed)\n')
        sys.exit(1)

    separator = "************************************************************";

    def dumpNoPacket(label, opt):
        if opt == 'l':
            print 'ERROR:', label, '-- No such packet.'
        elif opt == 'f':
            print separator
            print '*'
            print '* ERROR:', label
            print '*        No such packet.'
            print '*'
            print separator
            print

    def dumpPacketHeader(p):
        print separator
        print '*'
        print '* Label:', p.humanLabel()
        print '* Type: ', p.typeName()
        if p.parent:
            print '* Parent: ', p.parent().humanLabel()
        else:
            print '* Parent: (none)'
        if p.hasTags():
            print '* Tags:', string.join(', ', p.tags())
        print '*'
        print separator

    def dumpPacket(p, opt):
        if opt == 'l':
            print p.fullName()
        elif opt == 'f':
            dumpPacketHeader(p)
            print
            print p.detail()
            print

    filename = None
    packets = []
    opt = None
    count = False

    # Parse command line.
    for arg in sys.argv[1:]:
        if arg == '-c':
            count = True
        elif arg == '-f' or elif arg == '-l' or arg == '-n':
            if opt:
                usage('More than one detail level has been specified.')
            opt = arg[1]
        elif arg[:1] == '-':
            usage('Invalid option: ' + arg)
        elif not arg:
            usage('Empty arguments are not allowed.')
        elif filename:
            packets.append(arg)
        else:
            filename = arg

    if not filename:
        usage('No file has been specified.')

    # Add default options.
    if not opt:
        opt = 'f'
    if opt == 'n':
        count = True

    if opt == 'n' and packets:
        usage('You cannot specify individual packets if packets are not to be displayed.')

    # In the python implementation we will just write international characters
    # in utf8, and hope that the terminal is sufficiently modern to cope.

    # Do the actual work.
    tree = regina.open(filename)
    if not tree:
        sys.stderr.write('File ' + filename + ' could not be read.\n')
        sys.exit(1)

    if opt != 'n';
        if not packets:
            p = tree
            while p:
                dumpPacket(p, opt)
                p = p.nextTreePacket()
        else:
            for i in packets:
                p = tree.findPacketLabel(i)
                if p:
                    dumpPacket(p, opt)
                else:
                    dumpNoPacket(i, opt)

    if count:
        if opt != 'n':
            print
        print tree.totalTreeSize(), 'total packets in file.'

elif appName == 'regfiletype':
    def usage(error):
        if error:
            sys.stderr.write(error + '\n\n')

        sys.stderr.write('Usage:\n')
        sys.stderr.write('    ' + sys.argv[0] + ' <file> ...\n')
        sys.exit(1)

    if len(sys.argv) < 2:
        usage('Please specify one or more files.')

    for f in sys.argv[1:]:
        if len(sys.argv) > 2:
            print '[', f, ']'

        info = regina.NFileInfo.identify(f)
        if info:
            print info.detail(),
        else:
            print 'Unknown file format or file could not be opened.'

        if len(sys.argv) > 2:
            print

elif appName == 'trisetcmp':
    # TODO
    pass

else:
    globalUsage('"' + appName + '" is not one of Regina\'s command-line utilities.')
