
/**************************************************************************
 *                                                                        *
 *  Regina - A Normal Surface Theory Calculator                           *
 *  Computational Engine                                                  *
 *                                                                        *
 *  Copyright (c) 1999-2006, Ben Burton                                   *
 *  For further details contact Ben Burton (bab@debian.org).              *
 *                                                                        *
 *  This program is free software; you can redistribute it and/or         *
 *  modify it under the terms of the GNU General Public License as        *
 *  published by the Free Software Foundation; either version 2 of the    *
 *  License, or (at your option) any later version.                       *
 *                                                                        *
 *  This program is distributed in the hope that it will be useful, but   *
 *  WITHOUT ANY WARRANTY; without even the implied warranty of            *
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *
 *  General Public License for more details.                              *
 *                                                                        *
 *  You should have received a copy of the GNU General Public             *
 *  License along with this program; if not, write to the Free            *
 *  Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,       *
 *  MA 02110-1301, USA.                                                   *
 *                                                                        *
 **************************************************************************/

/* end stub */

#include <cctype>
#include <cstring>
#include <fstream>
#include <iomanip>
#include <iostream>

#include <qtextstream.h> // maybe this is overkill! 
#include <qstring.h>     // should think about ways
#include <qfile.h>       // of removing these...

#include "file/nresources.h"
#include "foreign/snappea.h"
#include "foreign/orb.h"
#include "triangulation/ntriangulation.h"
#include "foreign/casson.h"

namespace regina {
/* This file contains the engine routines to read Casson/Orb format triangulations
 * and import them into Regina.  The main routines are adapted from Damian
 * Heard's Orb. 
 *	The engine routines:
 *
 *For engine/engine/foreign directory
 *	the files casson.h, Makefile.am, orb.h, orb.cpp
 *
 * 	The GUI routine updates:
 *
 *For kdeui/src/part/foreign directory
 * 	orbhandler.cpp, orbhandler.h, Makefile.am
 *
 *For kdeui/src/part:
 * 	imports.cpp, reginafilter.h, actionspart.cpp, reginapart.h,
 *	I include reginapart.rc since I don't know if this is autogenerated
 *	or not. 
 *
 *For kdeui/src/common:
 *	reginafilter.h
 *
 * 					 -Ryan Budney (April 3rd, 2006)
*/ 

/* 
 *			1) included casson.h unmodified
 *			2) included readCassonFormat unmodified 				
 *			3) included verifyCassonFormat unmodified 
 *			4) included freeCassonFormat unmodified 
 *			5) modified cassonToTriangulation to be
 * 			   the Regina-compatible cassonToNTriangulation
*/

CassonFormat	*readCassonFormat( QTextStream &ts );
bool		verifyCassonFormat( CassonFormat *cf );
void		freeCassonFormat( CassonFormat *cf );
NTriangulation	*cassonToNTriangulation( CassonFormat *cf );



CassonFormat *readCassonFormat( QTextStream &ts )
{
        int             i;
        bool            ok;
        CassonFormat    *cf;
        QString         line,
                        section;
        EdgeInfo        *nei,
                        *ei;
        TetEdgeInfo     *ntei,
                        *tei;

	cf = new CassonFormat;
	cf->head = NULL;
	cf->num_tet = 0;
	ts.skipWhiteSpace();

	line = ts.readLine();

	while (!line.isEmpty() && line != "% diagram")
	{
		line = line.simplifyWhiteSpace();

		nei = new EdgeInfo;

                if (cf->head==NULL)
                        cf->head = nei;
                else	ei->next = nei;

		nei->next = NULL;
		nei->head = NULL;

		ei = nei;

		ei->index = line.section(' ',0,0).toInt(&ok,10) - 1;
		ei->singular_index = line.section(' ',1,1).toInt(&ok,10) - 1;
		ei->singular_order = line.section(' ',2,2).toDouble(&ok);	

		i = 3;
		section = line.section(' ',i,i);

		while (!section.isEmpty())	
		{
			ntei = new TetEdgeInfo;

			if (ei->head==NULL)
				ei->head        = ntei;
			else
				tei->next       = ntei;

			ntei->next = NULL;
			tei = ntei;

			tei->f1 = LN(section.at(section.length()-2).latin1());
			tei->f2 = LN(section.at(section.length()-1).latin1());
			section.truncate(section.length()-2);
			tei->tet_index = section.toInt(&ok,10) - 1;

			if (tei->tet_index + 1 > cf->num_tet)
				cf->num_tet = tei->tet_index + 1;

			i++;
			section = line.section(' ',i,i);
		}

		line = ts.readLine();
	}

	return cf;
}

bool verifyCassonFormat( CassonFormat *cf )
{
	int		i,j,k;
	bool		check[4][4];
	EdgeInfo	*ei;
	TetEdgeInfo	*tei;

	for(i=0;i<cf->num_tet;i++)
	{
		for(j=0;j<4;j++)
			for(k=0;k<4;k++)
			if (j==k)
				check[j][k] = TRUE;
			else	check[j][k] = FALSE;

		ei = cf->head;

		if (ei == NULL)
			return FALSE;

		while(ei!=NULL)
		{
			tei = ei->head;
			if (tei == NULL)
				return FALSE;
			while(tei!=NULL)
			{
				if (tei->tet_index == i )
				{
					if (check[tei->f1][tei->f2])
						return TRUE;
					check[tei->f1][tei->f2] = TRUE;
					check[tei->f2][tei->f1] = TRUE;
				}
				tei = tei->next;
			}
			ei = ei->next;
		}

		for(j=0;j<4;j++)
			for(k=0;k<4;k++)
			if (check[j][k]==FALSE)
				return FALSE;
	}
	return TRUE;
}

void freeCassonFormat( CassonFormat *cf )
{
	EdgeInfo *e1, *e2;
	TetEdgeInfo *t1, *t2;
	e1 = cf->head;

	while (e1!=NULL)
	{
		e2 = e1->next;
		t1 = e1->head;
		while (t1!=NULL)
		{
			t2 = t1->next;
			delete t1;
			t1 = t2;
		}
		delete e1;
		e1 = e2;
	}
	delete cf;
}

NTriangulation *readTriangulation( QTextStream &ts,  QString &file_id)
{

	NTriangulation *manifold;
	QString line = ts.readLine();
	CassonFormat *cf;

	if (line == "% orb")
	 {
         file_id = ts.readLine();
	 cf=readCassonFormat( ts );

	 if (verifyCassonFormat( cf ))
		 manifold = cassonToNTriangulation( cf );
	 else	
             {
		 std::cout<<"Error (3) reading Orb/Casson file.\n";std::cout.flush();
             }
	 }
	else std::cout<<"Error (2) reading Orb/Casson file.\n";std::cout.flush();

	freeCassonFormat( cf );
	return manifold;
}

NTriangulation *cassonToNTriangulation( CassonFormat *cf )
 {
 int i;
 NTriangulation *triang = new NTriangulation();
 // since CassonFormat does not allow naming of triangulations,
 //  triang is given a name in the readOrb() function.
 //  I try to mimic NTriangulation::readSnapPea and
 //  Orb::cassonToTriangulation as much as possible.
 NTetrahedron **tet = new NTetrahedron*[cf->num_tet]; // tet corresponds to tet_array in Orb
 for (i=0; i<cf->num_tet; i++)
	tet[i]=new NTetrahedron();
 // now tet is a pointer to an array of NTetrahedrons,
 //  so for each tet[i] we need to run
 //   for (j=0; j<4; j++)
 //     tet[i]->joinTo(j,tet[g[j]],NPerm(p[j][0],p[j][1],p[j][2],p[j][3],p[j][4]))
 //     where g[j] is the tetrahedron adjacent to face j of tet[i]
 //           p[j][k] is the permutation specifying how the faces are glued together.
 EdgeInfo *ei;
 TetEdgeInfo *tei1, *tei2;
 int t1, t2, a1, a2, a3, a4, b1, b2, b3, b4;
 ei = cf->head;

 // this routine goes through the edges of cf, picking off the adjacent
 // tetrahedra and assembled the information into tet. this code is
 // adapted from Orb::cassonToTriangulation in Orb's organizer.cpp
 while (ei!=NULL) // if we have a non-trivial edge, proceed
	{
	tei1 = ei->head;
	while (tei1!=NULL) // now we spin about the tetrahedra adj to ei.
		{
		if (tei1->next==NULL)
			tei2 = ei->head;
		else	tei2 = tei1->next;

		t1 = tei1->tet_index;
		a1 = tei1->f1;
		a2 = tei1->f2;
		a3 = vertex_at_faces[a1][a2];
		a4 = vertex_at_faces[a2][a1];

		t2 = tei2->tet_index;
		b1 = tei2->f1;
		b2 = tei2->f2;
		b3 = vertex_at_faces[b1][b2];
		b4 = vertex_at_faces[b2][b1];

		tet[t1]->joinTo( tei1->f1 , tet[t2], // 1st entry is the face of tet[t1]
				NPerm(a1,b2,a2,b1,a3,b3,a4,b4) ); // being attached to tet[t2]

		tet[t2]->joinTo( tei2->f2 , tet[t1],
				NPerm(b1,a2,b2,a1,b3,a3,b4,a4) );

		tei1 = tei1->next;
		}
	ei = ei->next;
	}
 
 for (i=0; i<cf->num_tet; i++)
	triang->addTetrahedron(tet[i]);
 delete[] tet;

 return triang; 
}

NTriangulation *readOrb(const char *filename) 
 {
   QString file_id;

   QString filename_qt(filename);
   QFile file_qt(filename_qt);
   if (!file_qt.open(IO_ReadOnly))
    {
     std::cout<<"Error (1) opening Orb/Casson file.\n";std::cout.flush();
    }
   QTextStream filestream_qt(&file_qt);
   NTriangulation *triang = readTriangulation(filestream_qt,file_id);

   const char *ascii_file_id=file_id.ascii();
   triang->setPacketLabel(ascii_file_id);
   return triang;
 }

} // namespace regina
