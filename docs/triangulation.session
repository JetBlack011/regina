
Regina 2.3
A Normal Surface Theory Calculator
Copyright (c) 1999-2001, Ben Burton

Jython 2.1b1 on java1.3.1 (JIT: null)

Running startup commands...
The calculation engine (type normal.engine.Engine) is in the variable [engine].

>>> # Create a new (3,4,7) layered solid torus.
>>> t = engine.newNTriangulation()
>>> t.insertLayeredSolidTorus(3,4)
Tetrahedron
>>> t
Triangulation with 3 tetrahedra.
>>> 
>>> # Dump skeletal information for the triangulation.
>>> print t.toStringLong()
Size of the skeleton:
  Tetrahedra: 3
  Faces: 7
  Edges: 5
  Vertices: 1

Tetrahedron gluing:
  Tet  |  glued to:      (012)      (013)      (023)      (123)
  -----+-------------------------------------------------------
    0  |              boundary   boundary    1 (012)    1 (130)
    1  |               0 (023)    0 (312)    2 (013)    2 (120)
    2  |               1 (312)    1 (023)    2 (312)    2 (230)

Vertices:
  Tet  |  vertex:    0   1   2   3
  -----+--------------------------
    0  |             0   0   0   0
    1  |             0   0   0   0
    2  |             0   0   0   0

Edges:
  Tet  |  edge:   01  02  03  12  13  23
  -----+--------------------------------
    0  |           0   1   2   2   1   3
    1  |           1   2   3   3   2   4
    2  |           2   4   3   3   4   3

Faces:
  Tet  |  face:  012 013 023 123
  -----+------------------------
    0  |           0   1   2   3
    1  |           2   3   4   5
    2  |           5   4   6   6


>>> 
>>> # Calculate various properties of the triangulation.
>>> t.getHomologyH1()
Z
>>> t.getHomologyH1Bdry()
2 Z
>>> t.isZeroEfficient()
0
>>> 
>>> # Get a list of normal surfaces in standard tri-quad coordinates.
>>> from normal.engine.surfaces import NNormalSurfaceList
>>> surfaces = engine.newNNormalSurfaceList(t, NNormalSurfaceList.STANDARD)
>>> 
>>> # Dump the entire list of vertex normal surfaces.
>>> print surfaces.toStringLong()
Embedded vertex normal surfaces
Coordinates: Standard normal (tri-quad)
Number of surfaces is 9
0 0 0 0 ; 0 1 0 || 0 0 0 0 ; 1 0 0 || 0 0 0 0 ; 0 1 0
0 0 1 1 ; 1 0 0 || 1 1 0 0 ; 1 0 0 || 0 0 0 0 ; 0 2 0
1 1 0 0 ; 0 0 1 || 1 1 0 0 ; 0 0 0 || 0 0 0 0 ; 0 1 0
1 1 1 1 ; 0 0 0 || 1 1 0 0 ; 1 0 0 || 0 0 0 0 ; 0 2 0
0 0 1 1 ; 1 0 0 || 1 1 1 1 ; 0 0 0 || 1 1 1 1 ; 0 0 0
0 0 0 0 ; 0 2 0 || 0 0 1 1 ; 1 0 0 || 1 1 1 1 ; 0 0 0
1 1 1 1 ; 0 0 0 || 1 1 1 1 ; 0 0 0 || 1 1 1 1 ; 0 0 0
0 0 0 0 ; 0 0 2 || 0 0 0 0 ; 0 2 0 || 0 0 1 1 ; 1 0 0
3 3 0 0 ; 0 0 1 || 1 1 0 0 ; 0 0 2 || 1 1 0 0 ; 0 0 1

>>> 
>>> # Print the Euler characteristic and orientability of each surface.
>>> for i in range(surfaces.getNumberOfSurfaces()):
...     s = surfaces.getSurface(i)
...     print "Chi =", s.getEulerCharacteristic(), "; Or =", s.isOrientable()
... 
Chi = -1 ; Or = -1
Chi = -2 ; Or = 1
Chi = 0 ; Or = -1
Chi = -1 ; Or = 1
Chi = 0 ; Or = 1
Chi = 0 ; Or = 1
Chi = 1 ; Or = 1
Chi = 0 ; Or = 1
Chi = 1 ; Or = 1
>>> 
>>> # List all the surfaces with more than one quad in the first tetrahedron.
>>> for i in range(surfaces.getNumberOfSurfaces()):
...     s = surfaces.getSurface(i)
...     if s.getQuadCoord(0,0) + s.getQuadCoord(0,1) + s.getQuadCoord(0,2) > 1:
...         print s
... 
0 0 0 0 ; 0 2 0 || 0 0 1 1 ; 1 0 0 || 1 1 1 1 ; 0 0 0
0 0 0 0 ; 0 0 2 || 0 0 0 0 ; 0 2 0 || 0 0 1 1 ; 1 0 0
>>> 
>>> # Tidy up.
>>> # Delete the triangulation; this will automatically delete the surface
>>> # list since the surface list is a child packet of the triangulation.
>>> t.destroy()
>>> 
